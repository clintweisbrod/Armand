#version 400

// Any TCS gets invoked once for each vertex in an input patch. Since we call glPatchParameteri(GL_PATCH_VERTICES, 3),
// this shader is called 3 times.

layout(vertices = 3) out;	// This means there will be 3 invocations of this shader for each vertex 
							// processed by the vertex shader.
in vec3 vNormal[];
in vec3 vMaterialAmbient[];
in vec3 vMaterialDiffuse[];
in vec3 vMaterialSpecular[];
in float vMaterialShininess[];
in vec2 vTexCoord[];

out vec3 tcNormal[];
out vec3 tcMaterialAmbient[];
out vec3 tcMaterialDiffuse[];
out vec3 tcMaterialSpecular[];
out float tcMaterialShininess[];
out vec2 tcTexCoord[];

//
// Uniforms
//
uniform mat4	uModelViewMatrix;	// Transforms model coordinates to eye coordinates.

#define ID gl_InvocationID	// gl_InvocationID will take values of 0, 1, 2 at each invocation of this
							// tessellation control shader.

void main()
{
	// Send the vertex positions along to tessellation evaluation shader.
	// The output patch is the same as in input patch.
	gl_out[ID].gl_Position = gl_in[ID].gl_Position;
	
	// Send the other vertex attributes along to tessellation evaluation shader.
	tcNormal[ID] = vNormal[ID];
	tcMaterialAmbient[ID] = vMaterialAmbient[ID];
	tcMaterialDiffuse[ID] = vMaterialDiffuse[ID];
	tcMaterialSpecular[ID] = vMaterialSpecular[ID];
	tcMaterialShininess[ID] = vMaterialShininess[ID];
	tcTexCoord[ID] = vTexCoord[ID];

	// We only need to write to the outputs; gl_TessLevelInner and gl_TessLevelOuter once per triangle.
	// Setting elements gl_TessLevelInner and gl_TessLevelOuter tells the tessellation primitive generator
	// how to tessellate this output patch.
	if (ID == 0)
	{
		// Compute the screen locations of the triangle vertices and use the distances in pixels between
		// each vertex to decide the level of tessellation.

		float outVertexEyeDistanceAU;
		vec3 normalizedVertexPositionInEyeCoords;
		
		// Compute dot products between each of the three vertices.
		vec3 vertexPositionInEyeCoords0 = normalize((uModelViewMatrix * gl_in[0].gl_Position).xyz);
		vec3 vertexPositionInEyeCoords1 = normalize((uModelViewMatrix * gl_in[1].gl_Position).xyz);
		vec3 vertexPositionInEyeCoords2 = normalize((uModelViewMatrix * gl_in[2].gl_Position).xyz);
		float dot01 = dot(vertexPositionInEyeCoords0, vertexPositionInEyeCoords1);
		float dot12 = dot(vertexPositionInEyeCoords1, vertexPositionInEyeCoords2);
		float dot20 = dot(vertexPositionInEyeCoords2, vertexPositionInEyeCoords0);
		
		// Assume no tesselation.
		float innerTessLevel = 1;
		float outerTessLevel = 1;
		
		const float kMinAngleInDegreesForNoTessellation = 10.0;
		const float kCosMinAngle = cos(kMinAngleInDegreesForNoTessellation * 3.14 / 180.0);
		if ((dot01 < kCosMinAngle) || (dot12 < kCosMinAngle) || (dot20 < kCosMinAngle))
		{
			// If we get here, the primitive has at least one dimension with an angular size
			// greater than 10 degrees, so we perform some modest tessellation.
			innerTessLevel = 3.0;
			outerTessLevel = 2.0;
		}
		
		// Only one element in inner array for triangles
		gl_TessLevelInner[0] = innerTessLevel;
		
		// Three elements for outer array. One for each side of triangle.
		gl_TessLevelOuter[0] = outerTessLevel;
		gl_TessLevelOuter[1] = outerTessLevel;
		gl_TessLevelOuter[2] = outerTessLevel;
	}
}