#version 400

// Any geometry shader is fed as input, one primitive defined by the vertix information located
// in gl_in[0 - N-1], where N is the number of vertices that compose the input primitive as
// declared in the input layout statement below. In this case, the input primitive is a triangle
// so N=3.
// A geometry shader outputs individual vertices to produce new primitives as defined in the
// output layout statement below. In this particular case, we are outputting triangle strips but
// we only want to output one triangle for each invocation of this shader. We therefore call
// EndPrimitive() after emitting 3 vertices.

layout(triangles) in;
layout(triangle_strip, max_vertices = 3) out;

in vec3 tePosition[3];
in vec3 tePatchDistance[3];
out vec3 gFacetNormal;
out vec3 gPatchDistance;
out vec3 gTriDistance;

uniform mat4 Modelview;
uniform mat3 NormalMatrix;

void main()
{
	// Compute the normal vector for the triangle we are about to emit. The normal
	// vector will be used by the fragment shader to perform some basic lighting
	// calculations.
	vec3 A = tePosition[2] - tePosition[0];
	vec3 B = tePosition[1] - tePosition[0];
	gFacetNormal = NormalMatrix * normalize(cross(A, B));
	
	// gPatchDistance is set to the gl_TessCoord of each vertex and its value will
	// be interpolated in the fragment shader. The interpolated value in the
	// fragment shader is used to modulate the fragment color to show thick black
	// lines along the boundary of each patch triangle that was sent to the TCS.
	// Similarly, gTriDistance is set to barycentric coordinates of the vertices
	// of each trianle we emit. The fragment shader will use the interpolated
	// coordinates to modulate the fragment color to show thin black lines along
	// the boundary of each triangle that has been generated by tessellation.
	
	gPatchDistance = tePatchDistance[0];
	gTriDistance = vec3(1, 0, 0);
	gl_Position = gl_in[0].gl_Position;
	EmitVertex();

	gPatchDistance = tePatchDistance[1];
	gTriDistance = vec3(0, 1, 0);
	gl_Position = gl_in[1].gl_Position;
	EmitVertex();

	gPatchDistance = tePatchDistance[2];
	gTriDistance = vec3(0, 0, 1);
	gl_Position = gl_in[2].gl_Position;
	EmitVertex();

	// Calling EndPrimitive() causes individual triangles to be output
	EndPrimitive();
}