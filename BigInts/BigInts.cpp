// BigInts.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include <iostream>
#include "ttmath/ttmath.h"

/*
See: http://www.ttmath.org/

I wrote this to flesh-out the use of 128-bit integers for representing Cartesian
coordinate axes for scales that cover the entire visible Universe. Given that the 
observable Universe is a sphere with radius on the order of 50 billion light years,
a light year is 9.46e15 metres, and there are 1000 millimetres in a metre. We have 
a radius of roughly 4.7e29 millimetres. The number of bits required to represent such
a number in integer format is:

bits = log(4.7e29)/log(2) = 98.6, rounded up to 99 bits, + 1 for signed.
     = 100 bits.

128 bits is therefore more than adequate to represent any object's position in the
Universe with millimetre precision. In fact, the extra 28 bits allows us to position
objects down to the millimeter in a universe 360 million times larger than our own!

------

Also, in the BigInts project Solution Explorer, you may notice the
ttmathuint_x86_64_msvc.obj file has been added. This file was generated by compiling
ttmath/ttmathuint_x86_64_msvc.asm with the following command line:

ml64.exe /c ttmathuint_x86_64_msvc.asm

yeilding the .obj file.

See: http://www.ttmath.org/forum/how_to_compile_with_visual_studio_2010_64-bit for an
explanation for why this is necessary. Essentially, without it we get link errors.
*/

int _tmain(int argc, _TCHAR* argv[])
{
	ttmath::Int<2> a, b;	// On x64 we need 2 values to represent 128 bits.
	ttmath::uint result;

	// Compute the largest value possible with signed 128-bit integer.
	a = 2;
	b = 127;
	result = a.Pow(b);	// result should be zero, meaning "no carry"

	// We decrement because the maximum value is 2^127 - 1
	a--;

	// Spit out the value to the console
	std::cout << a.ToString() << std::endl;

	return 0;
}

